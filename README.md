# Homework_webpython_08
 HW about MongoDB

Домашнее задание #8
Первая часть

    Создайте облачную базу данных Atlas MongoDB

    С помощью ODM Mongoengine создайте модели для хранения данных из этих файлов в коллекциях authors и quotes.

    При хранении цитат (quotes), поле автора в документе должно быть не строковым значением, а Reference fields полем, где хранится ObjectID из коллекции authors.

    Напишите скрипты для загрузки json файлов в облачную базу данных.

    Реализуйте скрипт для поиска цитат по тегу, по имени автора или набору тегов. Скрипт выполняется в бесконечном цикле и через обычный оператор input принимает команды в следующем формате команда:значение. Пример:
        name:Steve Martin — найти и вернуть список всех цитат автора Steve Martin;
        tag:life — найти и вернуть список цитат для тега life;
        tags:life,live — найти и вернуть список цитат, где есть теги life или live (примечание: без пробелов между тегами life,live);
        exit — закончить выполнение скрипта;

    Вывод результатов поиска только в формате utf-8;

Дополнительное задание

    Подумайте и реализуйте для команд name:Steve Martin и tag:life возможность сокращенной записи значений для поиска, как name:st и tag:li соответственно;
    Выполните кеширование результата выполнения команд name: и tag: с помощью Redis, чтобы при повторном запросе результат поиска брался не из MongoDB базы данных, а из кеша;

Вторая часть

Напишите два скрипта: consumer.py и producer.py. Используя RabbitMQ организуйте с помощью очередей имитацию рассылки email контактам.

Используя ODM Mongoengine создайте модель для контакта. Модель обязательно должна включать поля: полное имя, email и логическое поле, которое имеет значение False, по умолчанию. Оно означает, что сообщение контакту не отправлено и должно стать True, когда будет отправлено. Остальные поля для информационной нагрузки можете придумать сами.

При запуске скрипта producer.py он генерирует определенное количество фейковых контактов и записывает их в базу данных. Потом помещает в очередь RabbitMQ сообщение, которое содержит ObjectID созданного контакта, и так для всех сгенерированных контактов.

Скрипт consumer.py получает из очереди RabbitMQ сообщение, обрабатывает его и имитирует функцией-заглушкой отправку сообщения по email. После отправки сообщения, необходимо логическое поле для контакта установить в True. Скрипт работает постоянно в ожидании поступающих сообщений из RabbitMQ.

Дополнительное задание
Заведите в модели дополнительное поле телефонный номер. Также добавте поле отвечающее за предпочтительный способ отправки сообщений — SMS по телефону или email. Пусть producer.py отправляет в разные очереди контакты для SMS и email. Создайте два скрипта consumer_sms.py и consumer_email.py, каждый из которых получает свои контакты и обрабатывает их.